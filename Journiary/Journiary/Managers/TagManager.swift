//
//  TagManager.swift
//  Journiary
//
//  Created by Assistant on 06.11.25.
//

import Foundation
import CoreData
import SwiftUI
import MapKit

@MainActor
class TagManager: ObservableObject {
    private let viewContext: NSManagedObjectContext
    
    @Published var allTags: [Tag] = []
    @Published var allCategories: [TagCategory] = []
    @Published var filteredTags: [Tag] = []
    @Published var searchQuery: String = ""
    @Published var isInitialized = false
    
    // Computed property f√ºr tagCategories (Alias f√ºr allCategories)
    var tagCategories: [TagCategory] {
        return allCategories
    }
    
    // Alias f√ºr andere Views
    var categories: [TagCategory] {
        return allCategories
    }
    
    // Tags f√ºr eine bestimmte Kategorie
    func tags(for category: TagCategory) -> [Tag] {
        return allTags.filter { $0.category == category }
    }
    
    init(viewContext: NSManagedObjectContext) {
        self.viewContext = viewContext
        setupSystemTagsAndCategories()
        loadData()
        updateFilteredTags()
    }
    
    // MARK: - Data Loading
    
    func loadData() {
        loadTags()
        loadCategories()
    }
    
    private func loadTags() {
        let request: NSFetchRequest<Tag> = Tag.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Tag.name, ascending: true)]
        
        do {
            allTags = try viewContext.fetch(request)
        } catch {
            print("Fehler beim Laden der Tags: \(error)")
            allTags = []
        }
    }
    
    private func loadCategories() {
        let request: NSFetchRequest<TagCategory> = TagCategory.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \TagCategory.sortOrder, ascending: true)]
        
        do {
            allCategories = try viewContext.fetch(request)
        } catch {
            print("Fehler beim Laden der Kategorien: \(error)")
            allCategories = []
        }
    }
    
    // MARK: - Tag Operations
    
    func createTag(name: String, 
                   displayName: String? = nil, 
                   emoji: String? = nil, 
                   color: String = "blue", 
                   category: TagCategory? = nil) -> Tag? {
        let tag = Tag(context: viewContext)
        tag.id = UUID()
        tag.name = name.lowercased()
        tag.normalizedName = name.lowercased().folding(options: .diacriticInsensitive, locale: .current)
        tag.displayName = displayName ?? name
        tag.emoji = emoji
        tag.color = color
        tag.isSystemTag = false
        tag.usageCount = 0
        tag.createdAt = Date()
        tag.lastUsedAt = Date()
        tag.isArchived = false
        tag.sortOrder = 0
        
        if let category = category {
            tag.category = category
        }
        
        saveContext()
        loadTags()
        
        return tag
    }
    
    func updateTag(_ tag: Tag, 
                   name: String? = nil, 
                   displayName: String? = nil, 
                   emoji: String? = nil, 
                   color: String? = nil, 
                   category: TagCategory? = nil) {
        if let name = name {
            tag.name = name.lowercased()
            tag.normalizedName = name.lowercased().folding(options: .diacriticInsensitive, locale: .current)
        }
        if let displayName = displayName {
            tag.displayName = displayName
        }
        if let emoji = emoji {
            tag.emoji = emoji
        }
        if let color = color {
            tag.color = color
        }
        if let category = category {
            tag.category = category
        }
        
        saveContext()
        loadTags()
    }
    
    func deleteTag(_ tag: Tag) {
        viewContext.delete(tag)
        saveContext()
        loadTags()
    }
    
    func toggleTag(_ tag: Tag, for memory: Memory) {
        if memory.hasTag(tag) {
            memory.removeFromTags(tag)
            decrementUsage(for: tag)
        } else {
            memory.addToTags(tag)
            incrementUsage(for: tag)
        }
        saveContext()
    }
    
    private func incrementUsage(for tag: Tag) {
        tag.usageCount += 1
        tag.lastUsedAt = Date()
    }
    
    private func decrementUsage(for tag: Tag) {
        if tag.usageCount > 0 {
            tag.usageCount -= 1
        }
    }
    
    // MARK: - Category Operations
    
    func createCategory(name: String, 
                       displayName: String? = nil, 
                       emoji: String? = nil, 
                       color: String = "blue") -> TagCategory {
        let category = TagCategory(context: viewContext)
        category.id = UUID()
        category.name = name.lowercased()
        category.displayName = displayName ?? name
        category.emoji = emoji
        category.color = color
        category.isSystemCategory = false
        category.sortOrder = Int32(allCategories.count)
        category.isExpanded = true
        category.createdAt = Date()
        
        saveContext()
        loadCategories()
        
        return category
    }
    
    func updateCategory(_ category: TagCategory, 
                       name: String? = nil, 
                       displayName: String? = nil, 
                       emoji: String? = nil, 
                       color: String? = nil) {
        if let name = name {
            category.name = name.lowercased()
            category.displayName = displayName ?? name
        }
        if let displayName = displayName {
            category.displayName = displayName
        }
        if let emoji = emoji {
            category.emoji = emoji
        }
        if let color = color {
            category.color = color
        }
        
        saveContext()
        loadCategories()
    }
    
    func deleteCategory(_ category: TagCategory) {
        // Tags der Kategorie zu "uncategorized" verschieben
        if let tags = category.tags?.allObjects as? [Tag] {
            for tag in tags {
                tag.category = nil
            }
        }
        
        viewContext.delete(category)
        saveContext()
        loadCategories()
    }
    
    // MARK: - Search
    
    func search(query: String) {
        searchQuery = query
        updateFilteredTags()
    }
    
    func clearSearch() {
        searchQuery = ""
        updateFilteredTags()
    }
    
    func searchTags(query: String) -> [Tag] {
        guard !query.isEmpty else { return allTags.filter { !$0.isArchived } }
        
        let normalizedQuery = query.lowercased().folding(options: .diacriticInsensitive, locale: .current)
        
        return allTags.filter { tag in
            !tag.isArchived && (
                tag.normalizedName?.contains(normalizedQuery) == true ||
                tag.displayName?.lowercased().contains(normalizedQuery) == true ||
                tag.name?.contains(normalizedQuery) == true
            )
        }
    }
    
    // MARK: - Suggestions
    
    var frequentlyUsedTags: [Tag] {
        return allTags
            .filter { !$0.isArchived && $0.usageCount > 0 }
            .sorted { $0.usageCount > $1.usageCount }
            .prefix(10)
            .map { $0 }
    }
    
    func suggestTags(for memory: Memory) -> [Tag] {
        var suggestions: [Tag] = []
        
        // Zeitbasierte Vorschl√§ge
        if let date = memory.timestamp {
            let calendar = Calendar.current
            let hour = calendar.component(.hour, from: date)
            
            switch hour {
            case 5...11:
                suggestions.append(contentsOf: findOrCreateTags(["morgen", "fr√ºh"]))
            case 12...17:
                suggestions.append(contentsOf: findOrCreateTags(["mittag", "nachmittag"]))
            case 18...22:
                suggestions.append(contentsOf: findOrCreateTags(["abend"]))
            default:
                suggestions.append(contentsOf: findOrCreateTags(["nacht"]))
            }
        }
        
        // Ortsbasierte Vorschl√§ge
        if let locationName = memory.locationName?.lowercased() {
            let locationTags = analyzeLocationName(locationName)
            suggestions.append(contentsOf: locationTags)
        }
        
        // Textbasierte Vorschl√§ge
        if let text = memory.text?.lowercased() {
            let textTags = analyzeText(text)
            suggestions.append(contentsOf: textTags)
        }
        
        // Duplikate entfernen und bereits verwendete Tags ausschlie√üen
        let uniqueSuggestions = Array(Set(suggestions))
        return uniqueSuggestions.filter { !memory.hasTag($0) }
    }
    
    private func analyzeLocationName(_ locationName: String) -> [Tag] {
        var suggestions: [Tag] = []
        
        let locationKeywords: [String: [String]] = [
            "restaurant": ["üçΩÔ∏è", "restaurant", "essen"],
            "caf√©": ["‚òï", "caf√©", "kaffee"],
            "park": ["üå≥", "park", "natur"],
            "museum": ["üèõÔ∏è", "museum", "kultur"],
            "strand": ["üèñÔ∏è", "strand", "meer"],
            "berg": ["‚õ∞Ô∏è", "berg", "wandern"],
            "hotel": ["üè®", "hotel", "√ºbernachtung"],
            "flughafen": ["‚úàÔ∏è", "flughafen", "reise"],
            "bahnhof": ["üöÇ", "bahnhof", "reise"]
        ]
        
        for (keyword, tags) in locationKeywords {
            if locationName.contains(keyword) {
                suggestions.append(contentsOf: findOrCreateTags(tags))
            }
        }
        
        return suggestions
    }
    
    private func analyzeText(_ text: String) -> [Tag] {
        var suggestions: [Tag] = []
        
        let textKeywords: [String: [String]] = [
            "wandern": ["ü•æ", "wandern", "sport"],
            "essen": ["üçΩÔ∏è", "essen", "kulinarik"],
            "fotografie": ["üì∏", "fotografie", "hobby"],
            "strand": ["üèñÔ∏è", "strand", "entspannung"],
            "museum": ["üèõÔ∏è", "museum", "kultur"],
            "konzert": ["üéµ", "konzert", "musik"],
            "sport": ["‚öΩ", "sport", "aktivit√§t"],
            "familie": ["üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "familie", "zusammen"],
            "freunde": ["üë´", "freunde", "zusammen"]
        ]
        
        for (keyword, tags) in textKeywords {
            if text.contains(keyword) {
                suggestions.append(contentsOf: findOrCreateTags(tags))
            }
        }
        
        return suggestions
    }
    
    private func findOrCreateTags(_ tagNames: [String]) -> [Tag] {
        return tagNames.compactMap { tagName in
            // Erst versuchen zu finden
            if let existingTag = allTags.first(where: { $0.name == tagName.lowercased() }) {
                return existingTag
            }
            
            // Wenn nicht gefunden, erstellen
            let emoji = tagName.first?.isEmoji == true ? String(tagName.first!) : nil
            let name = emoji != nil ? String(tagName.dropFirst()) : tagName
            
            return createTag(
                name: name,
                displayName: name.capitalized,
                emoji: emoji,
                color: randomColor()
            )
        }
    }
    
    private func randomColor() -> String {
        let colors = ["blue", "green", "red", "orange", "purple", "pink", "yellow", "indigo", "teal", "cyan", "mint", "brown"]
        return colors.randomElement() ?? "blue"
    }
    
    // MARK: - System Setup
    
    private func setupSystemTagsAndCategories() {
        guard !isInitialized else { return }
        
        // Pr√ºfen ob bereits System-Kategorien existieren
        let request: NSFetchRequest<TagCategory> = TagCategory.fetchRequest()
        request.predicate = NSPredicate(format: "isSystemCategory == YES")
        
        do {
            let existingCategories = try viewContext.fetch(request)
            if !existingCategories.isEmpty {
                isInitialized = true
                return
            }
        } catch {
            print("Fehler beim Pr√ºfen der System-Kategorien: \(error)")
        }
        
        createSystemCategories()
        createSystemTags()
        
        isInitialized = true
        saveContext()
    }
    
    private func createSystemCategories() {
        let systemCategories = [
            ("orte", "üó∫Ô∏è", "Orte"),
            ("aktivit√§ten", "üéØ", "Aktivit√§ten"), 
            ("menschen", "üë•", "Menschen"),
            ("wetter", "üå§Ô∏è", "Wetter"),
            ("zeit", "‚è∞", "Zeit")
        ]
        
        for (index, (name, emoji, displayName)) in systemCategories.enumerated() {
            let category = TagCategory(context: viewContext)
            category.id = UUID()
            category.name = name
            category.displayName = displayName
            category.emoji = emoji
            category.color = "blue"
            category.isSystemCategory = true
            category.sortOrder = Int32(index)
            category.isExpanded = true
            category.createdAt = Date()
        }
    }
    
    private func createSystemTags() {
        let systemTags: [(String, String?, String, String)] = [
            // Orte
            ("restaurant", "üçΩÔ∏è", "Restaurant", "orte"),
            ("caf√©", "‚òï", "Caf√©", "orte"),
            ("park", "üå≥", "Park", "orte"),
            ("museum", "üèõÔ∏è", "Museum", "orte"),
            ("strand", "üèñÔ∏è", "Strand", "orte"),
            
            // Aktivit√§ten
            ("wandern", "ü•æ", "Wandern", "aktivit√§ten"),
            ("fotografie", "üì∏", "Fotografie", "aktivit√§ten"),
            ("sport", "‚öΩ", "Sport", "aktivit√§ten"),
            ("essen", "üçΩÔ∏è", "Essen", "aktivit√§ten"),
            ("entspannung", "üòå", "Entspannung", "aktivit√§ten"),
            
            // Menschen
            ("familie", "üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "Familie", "menschen"),
            ("freunde", "üë´", "Freunde", "menschen"),
            ("allein", "üßò", "Allein", "menschen"),
            
            // Wetter
            ("sonnig", "‚òÄÔ∏è", "Sonnig", "wetter"),
            ("regnerisch", "üåßÔ∏è", "Regnerisch", "wetter"),
            ("bew√∂lkt", "‚òÅÔ∏è", "Bew√∂lkt", "wetter"),
            
            // Zeit
            ("morgen", "üåÖ", "Morgen", "zeit"),
            ("mittag", "üåû", "Mittag", "zeit"),
            ("abend", "üåÖ", "Abend", "zeit"),
            ("nacht", "üåô", "Nacht", "zeit")
        ]
        
        for (name, emoji, displayName, categoryName) in systemTags {
            let tag = Tag(context: viewContext)
            tag.id = UUID()
            tag.name = name
            tag.normalizedName = name.folding(options: .diacriticInsensitive, locale: .current)
            tag.displayName = displayName
            tag.emoji = emoji
            tag.color = randomColor()
            tag.isSystemTag = true
            tag.usageCount = 0
            tag.createdAt = Date()
            tag.lastUsedAt = Date()
            tag.isArchived = false
            tag.sortOrder = 0
            
            // Kategorie zuweisen
            if let category = allCategories.first(where: { $0.name == categoryName }) {
                tag.category = category
            }
        }
    }
    
    // MARK: - Utility
    
    private func saveContext() {
        do {
            try viewContext.save()
        } catch {
            print("Fehler beim Speichern des Kontexts: \(error)")
        }
    }
    
    private func updateFilteredTags() {
        filteredTags = searchTags(query: searchQuery)
    }
    
    func setTags(_ tags: Set<Tag>, for memory: Memory) {
        // Alle aktuellen Tags entfernen
        let currentTags = memory.tagArray
        for tag in currentTags {
            memory.removeFromTags(tag)
            decrementUsage(for: tag)
        }
        
        // Neue Tags hinzuf√ºgen
        for tag in tags {
            memory.addToTags(tag)
            incrementUsage(for: tag)
        }
        
        saveContext()
    }
    
    func addTag(_ tag: Tag, to memory: Memory) {
        if !memory.hasTag(tag) {
            memory.addToTags(tag)
            incrementUsage(for: tag)
            saveContext()
        }
    }
    
    func removeTag(_ tag: Tag, from memory: Memory) {
        if memory.hasTag(tag) {
            memory.removeFromTags(tag)
            decrementUsage(for: tag)
            saveContext()
        }
    }
}

// MARK: - Extensions

extension Character {
    var isEmoji: Bool {
        return unicodeScalars.allSatisfy { scalar in
            scalar.properties.isEmojiPresentation ||
            scalar.properties.isEmojiModifier ||
            scalar.properties.isEmojiModifierBase ||
            (scalar.value >= 0x1F600 && scalar.value <= 0x1F64F) ||
            (scalar.value >= 0x1F300 && scalar.value <= 0x1F5FF) ||
            (scalar.value >= 0x1F680 && scalar.value <= 0x1F6FF) ||
            (scalar.value >= 0x2600 && scalar.value <= 0x26FF) ||
            (scalar.value >= 0x2700 && scalar.value <= 0x27BF)
        }
    }
} 