schema {
  query: Query
  mutation: Mutation
}
"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar DateTime
type Query {
  "Get all trips the logged-in user is a member of"
  trips: [Trip!]!
  "Get a single trip by ID."
  trip(id: ID!): Trip
  "Get all members of a trip"
  getTripMembers(tripId: ID!): [TripMembershipResponse!]!
  "Get all memories for trips the user is a member of"
  memories(tripId: ID): [Memory!]!
  "Get a single memory by ID"
  memory(id: String!): Memory
  "Search memories by query and optional trip filter"
  searchMemories(tripId: ID, query: String!): [Memory!]!
  "Generate a pre-signed URL to upload a file"
  getPresignedUploadUrl(mimeType: String!, filename: String!): PresignedUrlResponse!
  "Generate a pre-signed URL to download a file"
  getPresignedDownloadUrl(objectKey: String!): PresignedUrlResponse!
  routePoints(tripId: ID!): [RoutePoint!]!
  hello: String!
  tags: [Tag!]!
  tagCategories: [TagCategory!]!
  bucketListItems: [BucketListItem!]!
  "Get all GPX tracks for a specific trip."
  gpxTracksByTrip(tripId: ID!): [GPXTrack!]!
  "Get a single GPX track by its ID, including all its data."
  gpxTrack(id: ID!): GPXTrack
  "Get current user profile"
  getCurrentUser: User
  "Get all users for debugging (production: remove this)"
  listUsers: AdminResponse!
}
"Represents a single journey or trip"
type Trip {
  id: ID!
  name: String!
  tripDescription: String
  "The name of the cover image object in the storage (e.g., MinIO)"
  coverImageObjectName: String
  "A temporary URL to view the trip's cover image."
  coverImageUrl: String
  travelCompanions: String
  visitedCountries: String
  startDate: DateTime!
  endDate: DateTime
  isActive: Boolean!
  totalDistance: Float!
  gpsTrackingEnabled: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  memories: [Memory!]!
  routePoints: [RoutePoint!]!
  gpxTracks: [GPXTrack!]!
  trackSegments: [TrackSegment!]!
}
"Represents a single memory or event within a trip"
type Memory {
  id: ID!
  title: String!
  text: String
  content: String
  timestamp: DateTime!
  date: DateTime!
  latitude: Float!
  longitude: Float!
  locationName: String
  address: String
  "JSON string containing weather data"
  weatherJSON: String
  "A list of media items associated with this memory"
  mediaItems: [MediaItem!]!
  tags: [Tag!]!
  tripId: ID!
  gpxTrack: GPXTrack
  createdAt: DateTime!
  updatedAt: DateTime!
  userId: ID!
  location: Location
}
"Represents a media file (photo, video, etc.) associated with a memory"
type MediaItem {
  id: ID!
  mimeType: String!
  timestamp: DateTime!
  "The order of this item within the memory's media list"
  order: Int!
  s3Key: String!
  fileSize: Int!
  "For videos, the duration in seconds."
  duration: Float
  "The name of the thumbnail object in the storage (e.g., MinIO)"
  thumbnailS3Key: String
  memory: Memory!
  createdAt: DateTime!
  updatedAt: DateTime!
  "A temporary URL to download the full media file."
  downloadUrl: String
  "A temporary URL to download the thumbnail of the media file."
  thumbnailUrl: String
  filename: String!
  originalFilename: String
}
"A tag to categorize memories"
type Tag {
  id: ID!
  name: String!
  normalizedName: String
  displayName: String
  emoji: String
  color: String
  isSystemTag: Boolean!
  usageCount: Int!
  createdAt: DateTime!
  lastUsedAt: DateTime
  isArchived: Boolean!
  sortOrder: Int!
  tagDescription: String
  category: TagCategory
  relatedTags: [Tag!]
  categoryId: String
}
"Represents a category for grouping tags"
type TagCategory {
  id: ID!
  name: String!
  displayName: String
  emoji: String
  color: String
  isSystemCategory: Boolean!
  sortOrder: Int!
  isExpanded: Boolean!
  createdAt: DateTime!
  tags: [Tag!]!
}
"Represents a GPX track, which is a collection of track segments"
type GPXTrack {
  id: ID!
  name: String!
  description: String
  originalFilename: String
  "The name of the GPX file object in the storage (e.g., MinIO)"
  gpxFileObjectName: String
  totalDistance: Float
  totalDuration: Float
  averageSpeed: Float
  maxSpeed: Float
  elevationGain: Float
  elevationLoss: Float
  minElevation: Float
  maxElevation: Float
  totalPoints: Int
  startTime: DateTime
  endTime: DateTime
  creator: String
  trackType: String
  createdAt: DateTime!
  tripId: ID!
  "A temporary URL to download the GPX file."
  downloadUrl: String
  segments: [TrackSegment!]!
}
"A continuous segment of a GPX track, containing a series of points."
type TrackSegment {
  id: ID!
  points: [RoutePoint!]!
  segmentType: String
  compressionRatio: Float
  startDate: DateTime
  endDate: DateTime
  distance: Float
  averageSpeed: Float
  maxSpeed: Float
  originalPointCount: Int
  isCompressed: Boolean
  qualityLevel: String
  metadata: TrackMetadata
}
"Represents a single GPS point on a route"
type RoutePoint {
  id: ID!
  latitude: Float!
  longitude: Float!
  altitude: Float
  speed: Float
  timestamp: DateTime!
  created_at: DateTime!
}
"Represents metadata for a track segment"
type TrackMetadata {
  id: ID!
  transportationMode: String
  movementPattern: String
  terrainType: String
  weatherConditions: String
  batteryLevel: Float
  gpsAccuracy: Float
  elevationGain: Float
  elevationLoss: Float
  pauseDuration: Float
  createdAt: DateTime!
}
type Location {
  latitude: Float!
  longitude: Float!
  name: String
}
type TripMembershipResponse {
  id: ID!
  tripId: String!
  userId: String!
  role: TripRole!
  status: String!
  user: User!
  trip: Trip
  createdAt: DateTime!
}
"Represents a user of the application"
type User {
  id: ID!
  email: String!
  username: String!
  firstName: String
  lastName: String
  profileImageUrl: String
  isActive: Boolean!
  isEmailVerified: Boolean!
  lastLoginAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  displayName: String!
  initials: String!
  isOnline: Boolean!
}
type PresignedUrlResponse {
  uploadUrl: String!
  downloadUrl: String
  expiresIn: Float
  objectKey: String!
}
type BucketListItem {
  id: ID!
  name: String!
  country: String
  region: String
  type: String
  latitude1: Float
  longitude1: Float
  latitude2: Float
  longitude2: Float
  isDone: Boolean!
  createdAt: DateTime!
  completedAt: DateTime
  memories: [Memory!]
}
type AdminResponse {
  success: Boolean!
  message: String!
  users: [AdminUserInfo!]!
}
type AdminUserInfo {
  id: String!
  email: String!
  passwordHash: String!
  createdAt: DateTime!
}
type Mutation {
  "Create a new trip"
  createTrip(input: TripInput!): Trip!
  "Update an existing trip"
  updateTrip(input: UpdateTripInput!, id: ID!): Trip!
  "Generate a pre-signed URL to upload a trip cover image"
  generateTripCoverImageUploadUrl(contentType: String!, tripId: ID!): PresignedUrlResponse!
  "Assign a new cover image to a trip after upload"
  assignCoverImageToTrip(objectName: String!, tripId: ID!): Trip!
  "Delete a trip"
  deleteTrip(id: ID!): Boolean!
  "Share a trip with another user"
  shareTrip(permission: Permission!, email: String!, tripId: ID!): TripMembership!
  "Claim an existing trip for the current user (adds OWNER membership if missing)"
  claimTrip(tripId: ID!): Trip!
  "Create a new memory and associate it with a trip"
  createMemory(input: MemoryInput!): Memory!
  "Update an existing memory"
  updateMemory(input: UpdateMemoryInput!, id: String!): Memory!
  "Delete a memory"
  deleteMemory(id: String!): Boolean!
  "Generates a pre-signed URL to upload a file to MinIO."
  createUploadUrl(mimeType: String, filename: String!): PresignedUrlResponse!
  createMediaItem(input: MediaItemInput!): MediaItem!
  "Delete a media item"
  deleteMediaItem(id: String!): Boolean!
  createRoutePoints(points: [RoutePointInput!]!, tripId: ID!): [RoutePoint!]!
  createTag(input: TagInput!): Tag!
  updateTag(input: UpdateTagInput!, id: String!): Tag
  deleteTag(id: String!): Boolean!
  createTagCategory(input: TagCategoryInput!): TagCategory!
  updateTagCategory(input: UpdateTagCategoryInput!, id: String!): TagCategory
  deleteTagCategory(id: String!): Boolean!
  createBucketListItem(input: BucketListItemInput!): BucketListItem!
  updateBucketListItem(input: BucketListItemInput!, id: ID!): BucketListItem
  completeBucketListItem(memoryId: ID!, id: ID!): BucketListItem
  deleteBucketListItem(id: ID!): Boolean!
  "Generates a pre-signed URL to upload a GPX file."
  generateGpxUploadUrl(filename: String!): PresignedUrlResponse!
  "Creates a new GPX track record and processes the uploaded file."
  createGpxTrack(input: GPXTrackInput!): GPXTrack!
  "Processes an uploaded GPX file and creates the track data."
  processGpxFile(trackName: String!, tripId: ID!, objectName: String!): GPXTrack!
  "Deletes a GPX track and its associated data."
  deleteGpxTrack(id: ID!): Boolean!
  "Register a new user"
  register(input: UserInput!): User!
  "Log in a user"
  login(input: UserInput!): AuthResponse!
  "Update user profile"
  updateUser(input: UpdateUserInput!): User!
  "Reset user password (production: secure this endpoint)"
  resetUserPassword(newPassword: String!, email: String!): AdminResponse!
  "Create admin user if not exists"
  ensureAdminUser(password: String!, email: String!): AdminResponse!
}
type TripMembership {
  id: ID!
  role: TripRole!
}
type AuthResponse {
  token: String!
  user: User!
}
"The role of a user in a trip"
enum TripRole {
  OWNER
  EDITOR
  VIEWER
}
"User permission levels for trips"
enum Permission {
  READ
  WRITE
  ADMIN
}
"New trip data"
input TripInput {
  name: String!
  tripDescription: String
  travelCompanions: String
  visitedCountries: String
  startDate: DateTime!
  endDate: DateTime
  isActive: Boolean = false
  totalDistance: Float = 0
  gpsTrackingEnabled: Boolean = true
}
"Data to update an existing trip"
input UpdateTripInput {
  name: String
  tripDescription: String
  travelCompanions: String
  visitedCountries: String
  startDate: DateTime
  endDate: DateTime
  isActive: Boolean
  totalDistance: Float
  gpsTrackingEnabled: Boolean
}
"New memory data"
input MemoryInput {
  title: String!
  content: String
  date: DateTime
  latitude: Float
  longitude: Float
  address: String
  location: LocationInput
  "The ID of the trip this memory belongs to"
  tripId: ID!
  "A list of Tag IDs to associate with this memory"
  tagIds: [ID!]
}
"Represents a geographic location (latitude/longitude) plus optional name"
input LocationInput {
  latitude: Float!
  longitude: Float!
  name: String
}
"Update memory data"
input UpdateMemoryInput {
  title: String
  content: String
  date: DateTime
  latitude: Float
  longitude: Float
  location: LocationInput
  address: String
  "A list of Tag IDs to associate with this memory"
  tagIds: [String!]
}
"Input data for creating a new MediaItem"
input MediaItemInput {
  "The name of the object in the storage (e.g., from createUploadUrl)"
  objectName: String!
  "The name of the thumbnail object in the storage"
  thumbnailObjectName: String
  "The ID of the memory this media item belongs to"
  memoryId: String!
  "The type of media, e.g., 'image', 'video'."
  mediaType: String!
  "The timestamp of when the media was created"
  timestamp: DateTime!
  "The order of this item within the memory's media list"
  order: Int!
  "File size in bytes"
  filesize: Int!
  "For videos, the duration in seconds."
  duration: Int
}
"Input data to create a new RoutePoint"
input RoutePointInput {
  latitude: Float!
  longitude: Float!
  altitude: Float
  speed: Float
  timestamp: DateTime!
}
"Input data for creating a new Tag"
input TagInput {
  name: String!
  emoji: String
  color: String
  tagDescription: String
  "The ID of the category this tag belongs to"
  categoryId: ID
}
"Update tag data"
input UpdateTagInput {
  name: String
  color: String
  categoryId: ID
}
"Input data for creating a new Tag Category"
input TagCategoryInput {
  name: String!
  emoji: String
  color: String
}
"Update tag category data"
input UpdateTagCategoryInput {
  name: String
  color: String
  icon: String
}
input BucketListItemInput {
  name: String!
  country: String
  region: String
  type: String
  latitude1: Float
  longitude1: Float
  latitude2: Float
  longitude2: Float
  isDone: Boolean
}
"Input data for creating a new GPXTrack"
input GPXTrackInput {
  "The name of the GPX track"
  name: String!
  "The name of the uploaded GPX file in the object storage"
  gpxFileObjectName: String
  originalFilename: String
  "The ID of the trip this GPX track belongs to"
  tripId: ID!
  "Optional ID of the memory this GPX track is associated with"
  memoryId: ID
  creator: String
  trackType: String
}
"Input data for user registration and login"
input UserInput {
  email: String!
  password: String!
}
"Update user data"
input UpdateUserInput {
  username: String
  email: String
  firstName: String
  lastName: String
}
"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR
